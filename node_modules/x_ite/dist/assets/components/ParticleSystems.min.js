/* X_ITE v8.4.3 */(()=>{"use strict";var e={n:t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return e.d(n,{a:n}),n},d:(t,n)=>{for(var i in n)e.o(n,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:n[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Components");var n=e.n(t);const i=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Fields");var o=e.n(i);const r=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Base/X3DFieldDefinition");var s=e.n(r);const a=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Base/FieldDefinitionArray");var c=e.n(a);const l=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Components/Core/X3DNode");var u=e.n(l);const d=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Namespace");var m=e.n(d);let h=0;const p={POINT:h++,LINE:h++,TRIANGLE:h++,QUAD:h++,SPRITE:h++,GEOMETRY:h++};m().set("x_ite/Browser/ParticleSystems/GeometryTypes",p);const f=p,x=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Base/X3DConstants");var _=e.n(x);const g="\nstruct Line3 {\n   vec3 point;\n   vec3 direction;\n};\n\n// Line3\n// line3 (const in vec3 point1, const in vec3 point2)\n// {\n//    return Line3 (point1, normalize (point2 - point1));\n// }\n\n/* Line intersect triangle */\n\nbool\nintersects (const in Line3 line, const in vec3 a, const in vec3 b, const in vec3 c, out vec3 r)\n{\n   // find vectors for two edges sharing vert0\n   vec3 edge1 = b - a;\n   vec3 edge2 = c - a;\n\n   // begin calculating determinant - also used to calculate U parameter\n   vec3 pvec = cross (line .direction, edge2);\n\n   // if determinant is near zero, ray lies in plane of triangle\n   float det = dot (edge1, pvec);\n\n   // Non culling intersection\n\n   if (det == 0.0)\n      return false;\n\n   float inv_det = 1.0 / det;\n\n   // calculate distance from vert0 to ray point\n   vec3 tvec = line .point - a;\n\n   // calculate U parameter and test bounds\n   float u = dot (tvec, pvec) * inv_det;\n\n   if (u < 0.0 || u > 1.0)\n      return false;\n\n   // prepare to test V parameter\n   vec3 qvec = cross (tvec, edge1);\n\n   // calculate V parameter and test bounds\n   float v = dot (line .direction, qvec) * inv_det;\n\n   if (v < 0.0 || u + v > 1.0)\n      return false;\n\n   r = vec3 (u, v, 1.0 - u - v);\n\n   return true;\n}\n";m().set("x_ite/Browser/ParticleSystems/Line3.glsl",g);const y=g,v="\nstruct Plane3\n{\n   vec3  normal;\n   float distanceFromOrigin;\n};\n\nPlane3\nplane3 (const in vec3 point, const in vec3 normal)\n{\n   return Plane3 (normal, dot (normal, point));\n}\n\nfloat\nplane_distance (const in Plane3 plane, const in vec3 point)\n{\n   return dot (point, plane .normal) - plane .distanceFromOrigin;\n}\n\n/* Plane intersect line */\nbool\nintersects (const in Plane3 plane, const in Line3 line, out vec3 point)\n{\n   // Check if the line is parallel to the plane.\n   float theta = dot (line .direction, plane .normal);\n\n   // Plane and line are parallel.\n   if (theta == 0.0)\n      return false;\n\n   // Plane and line are not parallel. The intersection point can be calculated now.\n   float t = (plane .distanceFromOrigin - dot (plane .normal, line .point)) / theta;\n\n   point = line .point + line .direction * t;\n\n   return true;\n}\n\n/* Find find the first point that is farther to the plane than value. */\n// int\n// upper_bound (const in vec4 points [ARRAY_SIZE], in int count, const in float value, const in Plane3 plane)\n// {\n//    int first = 0;\n//    int step  = 0;\n\n//    while (count > 0)\n//    {\n//       int index = first;\n\n//       step = count >> 1;\n\n//       index += step;\n\n//       if (value < plane_distance (plane, points [index] .xyz))\n//       {\n//          count = step;\n//       }\n//       else\n//       {\n//          first  = ++ index;\n//          count -= step + 1;\n//       }\n//    }\n\n//    return first;\n// }\n\n/* CombSort: sort points in distance to a plane. */\nvoid\nsort (inout vec4 points [ARRAY_SIZE], const in int count, const in Plane3 plane)\n{\n   const float shrink = 1.0 / 1.3;\n\n   int  gap       = count;\n   bool exchanged = true;\n\n   while (exchanged)\n   {\n      gap = int (float (gap) * shrink);\n\n      if (gap <= 1)\n      {\n         exchanged = false;\n         gap       = 1;\n      }\n\n      for (int i = 0, l = count - gap; i < l; ++ i)\n      {\n         int j = gap + i;\n\n         if (plane_distance (plane, points [i] .xyz) > plane_distance (plane, points [j] .xyz))\n         {\n            vec4 tmp1 = points [i];\n            points [i] = points [j];\n            points [j] = tmp1;\n\n            exchanged = true;\n         }\n      }\n   }\n}\n\n\n// /* CombSort: sort points and normals in distance to a plane. */\n// void\n// sort (inout vec4 points [ARRAY_SIZE], inout vec3 normals [ARRAY_SIZE], const in int count, const in Plane3 plane)\n// {\n//    const float shrink = 1.0 / 1.3;\n\n//    int  gap       = count;\n//    bool exchanged = true;\n\n//    while (exchanged)\n//    {\n//       gap = int (float (gap) * shrink);\n\n//       if (gap <= 1)\n//       {\n//          exchanged = false;\n//          gap       = 1;\n//       }\n\n//       for (int i = 0, l = count - gap; i < l; ++ i)\n//       {\n//          int j = gap + i;\n\n//          if (plane_distance (plane, points [i] .xyz) > plane_distance (plane, points [j] .xyz))\n//          {\n//             vec4 tmp1 = points [i];\n//             points [i] = points [j];\n//             points [j] = tmp1;\n\n//             vec3 tmp2   = normals [i];\n//             normals [i] = normals [j];\n//             normals [j] = tmp2;\n\n//             exchanged = true;\n//          }\n//       }\n//    }\n// }\n\nint\nmin_index (const in vec4 points [ARRAY_SIZE], const in int count, const in float value, const in Plane3 plane)\n{\n   int   index = -1;\n   float dist  = 1000000.0;\n\n   for (int i = 0; i < count; ++ i)\n   {\n      float d = plane_distance (plane, points [i] .xyz);\n\n      if (d >= value && d < dist)\n      {\n         dist  = d;\n         index = i;\n      }\n   }\n\n   return index;\n}\n";m().set("x_ite/Browser/ParticleSystems/Plane3.glsl",v);const T=v,w="\nbool\nintersects (const in vec3 min, const in vec3 max, const in Line3 line)\n{\n   vec3 intersection;\n\n   // front\n\n   if (intersects (plane3 (max, vec3 (0.0, 0.0, 1.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xy, max .xy), vec4 (min .xy, intersection .xy))))\n         return true;\n   }\n\n   // back\n\n   if (intersects (plane3 (min, vec3 (0.0, 0.0, -1.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xy, max .xy), vec4 (min .xy, intersection .xy))))\n         return true;\n   }\n\n   // top\n\n   if (intersects (plane3 (max, vec3 (0.0, 1.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xz, max .xz), vec4 (min .xz, intersection .xz))))\n         return true;\n   }\n\n   // bottom\n\n   if (intersects (plane3 (min, vec3 (0.0, -1.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .xz, max .xz), vec4 (min .xz, intersection .xz))))\n         return true;\n   }\n\n   // right\n\n   if (intersects (plane3 (max, vec3 (1.0, 0.0, 0.0)), line, intersection))\n   {\n      if (all (greaterThanEqual (vec4 (intersection .yz, max .yz), vec4 (min .yz, intersection .yz))))\n         return true;\n   }\n\n   return false;\n}\n";m().set("x_ite/Browser/ParticleSystems/Box3.glsl",w);const R=w,b="\n#define BVH_NODE        0\n#define BVH_TRIANGLE    1\n#define BVH_STACK_SIZE  32\n\nint bvhNodeIndex = 0;\n\nvoid\nsetBVHIndex (const in int index)\n{\n   bvhNodeIndex = index;\n}\n\nint\ngetBVHRoot (const in sampler2D volume, const in int hierarchyIndex, const in int rootIndex)\n{\n   return int (texelFetch (volume, rootIndex, 0) .x) + hierarchyIndex;\n}\n\nint\ngetBVHType (const in sampler2D volume)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .x);\n}\n\nvec3\ngetBVHMin (const in sampler2D volume)\n{\n   return texelFetch (volume, bvhNodeIndex + 1, 0) .xyz;\n}\n\nvec3\ngetBVHMax (const in sampler2D volume)\n{\n   return texelFetch (volume, bvhNodeIndex + 2, 0) .xyz;\n}\n\nint\ngetBVHLeft (const in sampler2D volume, const in int hierarchyIndex)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .y) + hierarchyIndex;\n}\n\nint\ngetBVHRight (const in sampler2D volume, const in int hierarchyIndex)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .z) + hierarchyIndex;\n}\n\nint\ngetBVHTriangle (const in sampler2D volume)\n{\n   return int (texelFetch (volume, bvhNodeIndex, 0) .y);\n}\n\n/* Ray triangle intersection test */\n\nint\ngetIntersections (const in sampler2D volume, const in int verticesIndex, const in int hierarchyIndex, const in int rootIndex, const in Line3 line, out vec4 points [ARRAY_SIZE])\n{\n   int current    = getBVHRoot (volume, hierarchyIndex, rootIndex);\n   int count      = 0;\n   int stackIndex = -1;\n   int stack [BVH_STACK_SIZE];\n\n   while (stackIndex >= 0 || current >= 0)\n   {\n      if (current >= 0)\n      {\n         setBVHIndex (current);\n\n         if (getBVHType (volume) == BVH_NODE)\n         {\n            // Node\n\n            if (intersects (getBVHMin (volume), getBVHMax (volume), line))\n            {\n               stack [++ stackIndex] = current;\n\n               current = getBVHLeft (volume, hierarchyIndex);\n            }\n            else\n            {\n               current = -1;\n            }\n         }\n         else\n         {\n            // Triangle\n\n            int  t = getBVHTriangle (volume);\n            int  v = verticesIndex + t;\n            vec3 r = vec3 (0.0);\n\n            vec3 a = texelFetch (volume, v,     0) .xyz;\n            vec3 b = texelFetch (volume, v + 1, 0) .xyz;\n            vec3 c = texelFetch (volume, v + 2, 0) .xyz;\n\n            if (intersects (line, a, b, c, r))\n               points [count ++] = vec4 (r .z * a + r .x * b + r .y * c, 1.0);\n\n            current = -1;\n         }\n      }\n      else\n      {\n         setBVHIndex (stack [stackIndex --]);\n\n         current = getBVHRight (volume, hierarchyIndex);\n      }\n   }\n\n   return count;\n}\n\nint\ngetIntersections (const in sampler2D volume, const in int verticesIndex, const in int normalsIndex, const in int hierarchyIndex, const in int rootIndex, const in Line3 line, out vec4 points [ARRAY_SIZE], out vec3 normals [ARRAY_SIZE])\n{\n   int current    = getBVHRoot (volume, hierarchyIndex, rootIndex);\n   int count      = 0;\n   int stackIndex = -1;\n   int stack [BVH_STACK_SIZE];\n\n   while (stackIndex >= 0 || current >= 0)\n   {\n      if (current >= 0)\n      {\n         setBVHIndex (current);\n\n         if (getBVHType (volume) == BVH_NODE)\n         {\n            // Node\n\n            if (intersects (getBVHMin (volume), getBVHMax (volume), line))\n            {\n               stack [++ stackIndex] = current;\n\n               current = getBVHLeft (volume, hierarchyIndex);\n            }\n            else\n            {\n               current = -1;\n            }\n         }\n         else\n         {\n            // Triangle\n\n            int  t = getBVHTriangle (volume);\n            int  v = verticesIndex + t;\n            vec3 r = vec3 (0.0);\n\n            vec3 a = texelFetch (volume, v,     0) .xyz;\n            vec3 b = texelFetch (volume, v + 1, 0) .xyz;\n            vec3 c = texelFetch (volume, v + 2, 0) .xyz;\n\n            if (intersects (line, a, b, c, r))\n            {\n               points [count] = vec4 (r .z * a + r .x * b + r .y * c, 1.0);\n\n               int n = normalsIndex + t;\n\n               vec3 n0 = texelFetch (volume, n,     0) .xyz;\n               vec3 n1 = texelFetch (volume, n + 1, 0) .xyz;\n               vec3 n2 = texelFetch (volume, n + 2, 0) .xyz;\n\n               normals [count] = save_normalize (r .z * n0 + r .x * n1 + r .y * n2);\n\n               ++ count;\n            }\n\n            current = -1;\n         }\n      }\n      else\n      {\n         setBVHIndex (stack [stackIndex --]);\n\n         current = getBVHRight (volume, hierarchyIndex);\n      }\n   }\n\n   return count;\n}\n";m().set("x_ite/Browser/ParticleSystems/BVH.glsl",b);const F=b;function I(e){u().call(this,e),this.addType(_().X3DParticleEmitterNode),this._speed.setUnit("speed"),this._mass.setUnit("mass"),this._surfaceArea.setUnit("area"),this.samplers=[],this.uniforms={},this.functions=[],this.program=null,this.addSampler("forces"),this.addSampler("boundedVolume"),this.addSampler("colorRamp"),this.addSampler("texCoordRamp"),this.addUniform("speed","uniform float speed;"),this.addUniform("variation","uniform float variation;"),this.addFunction(y),this.addFunction(T),this.addFunction(R),this.addFunction(F)}I.prototype=Object.assign(Object.create(u().prototype),{constructor:I,initialize:function(){u().prototype.initialize.call(this);const e=this.getBrowser().getContext();e.getVersion()<2||(this.program=this.createProgram(),this.transformFeedback=e.createTransformFeedback(),this._on.addInterest("set_on__",this),this._speed.addInterest("set_speed__",this),this._variation.addInterest("set_variation__",this),this._mass.addInterest("set_mass__",this),this.set_on__(),this.set_speed__(),this.set_variation__(),this.set_mass__())},isExplosive:function(){return!1},getMass:function(){return this.mass},set_on__:function(){this.on=this._on.getValue()},set_speed__:function(){this.setUniform("uniform1f","speed",this._speed.getValue())},set_variation__:function(){this.setUniform("uniform1f","variation",this._variation.getValue())},set_mass__:function(){this.mass=this._mass.getValue()},getRandomValue:function(e,t){return Math.random()*(t-e)+e},getRandomNormal:function(e){const t=this.getRandomValue(-1,1)*Math.PI,n=this.getRandomValue(-1,1),i=Math.acos(n),o=Math.sin(i);return e.set(Math.sin(t)*o,Math.cos(t)*o,n)},animate:function(e,t){const n=this.getBrowser().getContext(),i=e.inputParticles,o=e.particleStride,r=e.particleOffsets,s=this.program;if(n.useProgram(s),n.uniform1i(s.randomSeed,4294967295*Math.random()),n.uniform1i(s.geometryType,e.geometryType),n.uniform1i(s.createParticles,e.createParticles&&this.on),n.uniform1f(s.particleLifetime,e.particleLifetime),n.uniform1f(s.lifetimeVariation,e.lifetimeVariation),n.uniform1f(s.deltaTime,t),n.uniform2f(s.particleSize,e._particleSize.x,e._particleSize.y),n.uniform1i(s.numForces,e.numForces),e.numForces&&(n.activeTexture(n.TEXTURE0+s.forcesTextureUnit),n.bindTexture(n.TEXTURE_2D,e.forcesTexture)),e.boundedHierarchyRoot<0?n.uniform1i(s.boundedHierarchyRoot,-1):(n.uniform1i(s.boundedVerticesIndex,e.boundedVerticesIndex),n.uniform1i(s.boundedNormalsIndex,e.boundedNormalsIndex),n.uniform1i(s.boundedHierarchyIndex,e.boundedHierarchyIndex),n.uniform1i(s.boundedHierarchyRoot,e.boundedHierarchyRoot),n.activeTexture(n.TEXTURE0+s.boundedVolumeTextureUnit),n.bindTexture(n.TEXTURE_2D,e.boundedTexture)),n.uniform1i(s.numColors,e.numColors),e.numColors&&(n.activeTexture(n.TEXTURE0+s.colorRampTextureUnit),n.bindTexture(n.TEXTURE_2D,e.colorRampTexture)),n.uniform1i(s.numTexCoords,e.numTexCoords),e.numTexCoords&&(n.uniform1i(s.texCoordCount,e.texCoordCount),n.activeTexture(n.TEXTURE0+s.texCoordRampTextureUnit),n.bindTexture(n.TEXTURE_2D,e.texCoordRampTexture)),this.activateTextures(n,s),i.emitterArrayObject.enable(n,s)){for(const[e,t]of s.inputs)n.bindBuffer(n.ARRAY_BUFFER,i),n.enableVertexAttribArray(t),n.vertexAttribPointer(t,4,n.FLOAT,!1,o,r[e]);n.bindBuffer(n.ARRAY_BUFFER,null)}n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.transformFeedback),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,e.outputParticles),n.enable(n.RASTERIZER_DISCARD),n.beginTransformFeedback(n.POINTS),n.drawArrays(n.POINTS,0,e.numParticles),n.endTransformFeedback(),n.disable(n.RASTERIZER_DISCARD),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null)},addSampler:function(e){this.samplers.push(e)},addUniform:function(e,t){this.uniforms[e]=t},setUniform:function(e,t,n,i,o){const r=this.getBrowser().getContext(),s=this.program;r.useProgram(s),r[e](s[t],n,i,o)},addFunction:function(e){this.functions.push(e)},createProgram:function(){const e=this.getBrowser(),t=e.getContext(),n=`#version 300 es\n\n      precision highp float;\n      precision highp int;\n      precision highp sampler2D;\n\n      uniform int   randomSeed;\n      uniform int   geometryType;\n      uniform bool  createParticles;\n      uniform float particleLifetime;\n      uniform float lifetimeVariation;\n      uniform float deltaTime;\n      uniform vec2  particleSize;\n\n      uniform int       numForces;\n      uniform sampler2D forces;\n\n      uniform int       boundedVerticesIndex;\n      uniform int       boundedNormalsIndex;\n      uniform int       boundedHierarchyIndex;\n      uniform int       boundedHierarchyRoot;\n      uniform sampler2D boundedVolume;\n\n      uniform int       numColors;\n      uniform sampler2D colorRamp;\n\n      uniform int       texCoordCount;\n      uniform int       numTexCoords;\n      uniform sampler2D texCoordRamp;\n\n      ${Object.values(this.uniforms).join("\n")}\n\n      in vec4 input0;\n      in vec4 input2;\n      in vec4 input6;\n\n      out vec4 output0;\n      out vec4 output1;\n      out vec4 output2;\n\n      out vec4 output3;\n      out vec4 output4;\n      out vec4 output5;\n      out vec4 output6;\n\n      // Constants\n\n      ${Object.entries(f).map((([e,t])=>`#define ${e} ${t}`)).join("\n")}\n\n      const int   ARRAY_SIZE = 32;\n      const float M_PI       = 3.14159265359;\n\n      uniform float NaN;\n\n      // Texture\n\n      vec4\n      texelFetch (const in sampler2D sampler, const in int index, const in int lod)\n      {\n         int   x = textureSize (sampler, lod) .x;\n         ivec2 p = ivec2 (index % x, index / x);\n         vec4  t = texelFetch (sampler, p, lod);\n\n         return t;\n      }\n\n      // Math\n\n      // Save normalize, that will not divide by zero.\n      vec3\n      save_normalize (const in vec3 vector)\n      {\n         float l = length (vector);\n\n         if (l == 0.0)\n            return vec3 (0.0);\n\n         return vector / l;\n      }\n\n      // Quaternion\n\n      vec4\n      Quaternion (const in vec3 fromVector, const in vec3 toVector)\n      {\n         vec3 from = save_normalize (fromVector);\n         vec3 to   = save_normalize (toVector);\n\n         float cos_angle = dot (from, to);\n         vec3  cross_vec = cross (from, to);\n         float cross_len = length (cross_vec);\n\n         if (cross_len == 0.0)\n         {\n            if (cos_angle > 0.0)\n            {\n               return vec4 (0.0, 0.0, 0.0, 1.0);\n            }\n            else\n            {\n               vec3 t = cross (from, vec3 (1.0, 0.0, 0.0));\n\n               if (dot (t, t) == 0.0)\n                  t = cross (from, vec3 (0.0, 1.0, 0.0));\n\n               t = save_normalize (t);\n\n               return vec4 (t, 0.0);\n            }\n         }\n         else\n         {\n            float s = sqrt (abs (1.0 - cos_angle) * 0.5);\n\n            cross_vec = save_normalize (cross_vec);\n\n            return vec4 (cross_vec * s, sqrt (abs (1.0 + cos_angle) * 0.5));\n         }\n      }\n\n      vec3\n      multVecQuat (const in vec3 v, const in vec4 q)\n      {\n         float a = q .w * q .w - q .x * q .x - q .y * q .y - q .z * q .z;\n         float b = 2.0 * (v .x * q .x + v .y * q .y + v .z * q .z);\n         float c = 2.0 * q .w;\n         vec3  r = a * v .xyz + b * q .xyz + c * (q .yzx * v .zxy - q .zxy * v .yzx);\n\n         return r;\n      }\n\n      mat3\n      Matrix3 (const in vec4 quaternion)\n      {\n         float x = quaternion .x;\n         float y = quaternion .y;\n         float z = quaternion .z;\n         float w = quaternion .w;\n         float A = y * y;\n         float B = z * z;\n         float C = x * y;\n         float D = z * w;\n         float E = z * x;\n         float F = y * w;\n         float G = x * x;\n         float H = y * z;\n         float I = x * w;\n\n         return mat3 (1.0 - 2.0 * (A + B),\n                      2.0 * (C + D),\n                      2.0 * (E - F),\n                      2.0 * (C - D),\n                      1.0 - 2.0 * (B + G),\n                      2.0 * (H + I),\n                      2.0 * (E + F),\n                      2.0 * (H - I),\n                      1.0 - 2.0 * (A + G));\n      }\n\n      /* Random number generation */\n\n      uint seed = 1u;\n\n      void\n      srand (const in int value)\n      {\n         seed = uint (value);\n      }\n\n      // Return a uniform distributed random floating point number in the interval [0, 1].\n      float\n      random ()\n      {\n         seed = seed * 1103515245u + 12345u;\n\n         return float (seed) / 4294967295.0;\n      }\n\n      float\n      getRandomValue (const in float min, const in float max)\n      {\n         return min + random () * (max - min);\n      }\n\n      float\n      getRandomLifetime ()\n      {\n         float v    = particleLifetime * lifetimeVariation;\n         float min_ = max (0.0, particleLifetime - v);\n         float max_ = particleLifetime + v;\n\n         return getRandomValue (min_, max_);\n      }\n\n      float\n      getRandomSpeed ()\n      {\n         float v    = speed * variation;\n         float min_ = max (0.0, speed - v);\n         float max_ = speed + v;\n\n         return getRandomValue (min_, max_);\n      }\n\n      vec3\n      getRandomNormal ()\n      {\n         float theta = getRandomValue (-M_PI, M_PI);\n         float cphi  = getRandomValue (-1.0, 1.0);\n         float r     = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n\n         return vec3 (sin (theta) * r, cos (theta) * r, cphi);\n      }\n\n      vec3\n      getRandomNormalWithAngle (const in float angle)\n      {\n         float theta = getRandomValue (-M_PI, M_PI);\n         float cphi  = getRandomValue (cos (angle), 1.0);\n         float r     = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n\n         return vec3 (sin (theta) * r, cos (theta) * r, cphi);\n      }\n\n      vec3\n      getRandomNormalWithDirectionAndAngle (const in vec3 direction, const in float angle)\n      {\n         vec4 rotation = Quaternion (vec3 (0.0, 0.0, 1.0), direction);\n         vec3 normal   = getRandomNormalWithAngle (angle);\n\n         return multVecQuat (normal, rotation);\n      }\n\n      vec3\n      getRandomSurfaceNormal (const in vec3 direction)\n      {\n         float theta    = getRandomValue (-M_PI, M_PI);\n         float cphi     = pow (random (), 1.0 / 3.0);\n         float r        = sqrt (1.0 - cphi * cphi); // sin (acos (cphi));\n         vec3  normal   = vec3 (sin (theta) * r, cos (theta) * r, cphi);\n         vec4  rotation = Quaternion (vec3 (0.0, 0.0, 1.0), direction);\n\n         return multVecQuat (normal, rotation);\n      }\n\n      vec3\n      getRandomSphericalVelocity ()\n      {\n         vec3  normal = getRandomNormal ();\n         float speed  = getRandomSpeed ();\n\n         return normal * speed;\n      }\n\n      // Algorithms\n\n      int\n      upperBound (const in sampler2D sampler, in int count, const in float value)\n      {\n         int first = 0;\n         int step  = 0;\n\n         while (count > 0)\n         {\n            int index = first;\n\n            step = count >> 1;\n\n            index += step;\n\n            if (value < texelFetch (sampler, index, 0) .x)\n            {\n               count = step;\n            }\n            else\n            {\n               first  = ++ index;\n               count -= step + 1;\n            }\n         }\n\n         return first;\n      }\n\n      void\n      interpolate (const in sampler2D sampler, const in int count, const in float fraction, out int index0, out int index1, out float weight)\n      {\n         // Determine index0, index1 and weight.\n\n         if (count == 1 || fraction <= texelFetch (sampler, 0, 0) .x)\n         {\n            index0 = 0;\n            index1 = 0;\n            weight = 0.0;\n         }\n         else if (fraction >= texelFetch (sampler, count - 1, 0) .x)\n         {\n            index0 = count - 2;\n            index1 = count - 1;\n            weight = 1.0;\n         }\n         else\n         {\n            int index = upperBound (sampler, count, fraction);\n\n            if (index < count)\n            {\n               index1 = index;\n               index0 = index - 1;\n\n               float key0 = texelFetch (sampler, index0, 0) .x;\n               float key1 = texelFetch (sampler, index1, 0) .x;\n\n               weight = clamp ((fraction - key0) / (key1 - key0), 0.0, 1.0);\n            }\n            else\n            {\n               index0 = 0;\n               index1 = 0;\n               weight = 0.0;\n            }\n         }\n      }\n\n      void\n      interpolate (const in sampler2D sampler, const in int count, const in float fraction, out int index0)\n      {\n         // Determine index0.\n\n         if (count == 1 || fraction <= texelFetch (sampler, 0, 0) .x)\n         {\n            index0 = 0;\n         }\n         else if (fraction >= texelFetch (sampler, count - 1, 0) .x)\n         {\n            index0 = count - 2;\n         }\n         else\n         {\n            int index = upperBound (sampler, count, fraction);\n\n            if (index < count)\n               index0 = index - 1;\n            else\n               index0 = 0;\n         }\n      }\n\n      vec3\n      getRandomBarycentricCoord ()\n      {\n         // Random barycentric coordinates.\n\n         float u = random ();\n         float v = random ();\n\n         if (u + v > 1.0)\n         {\n            u = 1.0 - u;\n            v = 1.0 - v;\n         }\n\n         float t = 1.0 - u - v;\n\n         return vec3 (t, u, v);\n      }\n\n      void\n      getRandomPointOnSurface (const in sampler2D surface, const in int verticesIndex, const in int normalsIndex, out vec4 position, out vec3 normal)\n      {\n         // Determine index0, index1 and weight.\n\n         float lastAreaSoFar = texelFetch (surface, verticesIndex - 1, 0) .x;\n         float fraction      = random () * lastAreaSoFar;\n\n         int   index0;\n         int   index1;\n         int   index2;\n         float weight;\n\n         interpolate (surface, verticesIndex, fraction, index0, index1, weight);\n\n         // Interpolate and return position.\n\n         index0 *= 3;\n         index1  = index0 + 1;\n         index2  = index0 + 2;\n\n         vec4 vertex0 = texelFetch (surface, verticesIndex + index0, 0);\n         vec4 vertex1 = texelFetch (surface, verticesIndex + index1, 0);\n         vec4 vertex2 = texelFetch (surface, verticesIndex + index2, 0);\n\n         vec3 normal0 = texelFetch (surface, normalsIndex + index0, 0) .xyz;\n         vec3 normal1 = texelFetch (surface, normalsIndex + index1, 0) .xyz;\n         vec3 normal2 = texelFetch (surface, normalsIndex + index2, 0) .xyz;\n\n         // Random barycentric coordinates.\n\n         vec3 r = getRandomBarycentricCoord ();\n\n         // Calculate position and direction.\n\n         position = r .z * vertex0 + r .x * vertex1 + r .y * vertex2;\n         normal   = save_normalize (r .z * normal0 + r .x * normal1 + r .y * normal2);\n      }\n\n      // Functions\n\n      ${this.functions.join("\n")}\n\n      // Current values\n\n      vec4\n      getColor (const in float lifetime, const in float elapsedTime)\n      {\n         if (numColors > 0)\n         {\n            // Determine index0, index1 and weight.\n\n            float fraction = elapsedTime / lifetime;\n\n            int   index0;\n            int   index1;\n            float weight;\n\n            interpolate (colorRamp, numColors, fraction, index0, index1, weight);\n\n            // Interpolate and return color.\n\n            vec4 color0 = texelFetch (colorRamp, numColors + index0, 0);\n            vec4 color1 = texelFetch (colorRamp, numColors + index1, 0);\n\n            return mix (color0, color1, weight);\n         }\n         else\n         {\n            return vec4 (1.0);\n         }\n      }\n\n      void\n      bounce (const in vec4 fromPosition, inout vec4 toPosition, inout vec3 velocity)\n      {\n         if (boundedHierarchyRoot < 0)\n            return;\n\n         Line3 line = Line3 (fromPosition .xyz, save_normalize (velocity));\n\n         vec4 points  [ARRAY_SIZE];\n         vec3 normals [ARRAY_SIZE];\n\n         int numIntersections = getIntersections (boundedVolume, boundedVerticesIndex, boundedNormalsIndex, boundedHierarchyIndex, boundedHierarchyRoot, line, points, normals);\n\n         if (numIntersections == 0)\n            return;\n\n         Plane3 plane1 = plane3 (line .point, line .direction);\n\n         int index = min_index (points, numIntersections, 0.0, plane1);\n\n         if (index == -1)\n            return;\n\n         Plane3 plane2 = plane3 (points [index] .xyz, normals [index]);\n\n         if (sign (plane_distance (plane2, fromPosition .xyz)) == sign (plane_distance (plane2, toPosition .xyz)))\n            return;\n\n         velocity   = reflect (velocity, normals [index]);\n         toPosition = vec4 (points [index] .xyz + reflect (points [index] .xyz - fromPosition .xyz, normals [index]), 1.0);\n      }\n\n      int\n      getTexCoordIndex0 (const in float lifetime, const in float elapsedTime)\n      {\n         if (numTexCoords == 0)\n         {\n            return -1;\n         }\n         else\n         {\n            float fraction = elapsedTime / lifetime;\n            int   index0   = 0;\n\n            interpolate (texCoordRamp, numTexCoords, fraction, index0);\n\n            return numTexCoords + index0 * texCoordCount;\n         }\n      }\n\n      void\n      main ()\n      {\n         int   life        = int (input0 [0]);\n         float lifetime    = input0 [1];\n         float elapsedTime = input0 [2] + deltaTime;\n\n         srand ((gl_VertexID + randomSeed) * randomSeed);\n\n         if (elapsedTime > lifetime)\n         {\n            // Create new particle or hide particle.\n\n            lifetime    = getRandomLifetime ();\n            elapsedTime = 0.0;\n\n            output0 = vec4 (max (life + 1, 1), lifetime, elapsedTime, getTexCoordIndex0 (lifetime, elapsedTime));\n\n            if (createParticles)\n            {\n               output1 = getColor (lifetime, elapsedTime);\n               output2 = vec4 (getRandomVelocity (), 0.0);\n               output6 = getRandomPosition ();\n            }\n            else\n            {\n               output1 = vec4 (0.0);\n               output2 = vec4 (0.0);\n               output6 = vec4 (NaN);\n            }\n         }\n         else\n         {\n            // Animate particle.\n\n            vec3 velocity = input2 .xyz;\n            vec4 position = input6;\n\n            for (int i = 0; i < numForces; ++ i)\n            {\n               vec4  force      = texelFetch (forces, i, 0);\n               float turbulence = force .w;\n               vec3  normal     = getRandomNormalWithDirectionAndAngle (force .xyz, turbulence);\n               float speed      = length (force .xyz);\n\n               velocity += normal * speed;\n            }\n\n            position .xyz += velocity * deltaTime;\n\n            bounce (input6, position, velocity);\n\n            output0 = vec4 (life, lifetime, elapsedTime, getTexCoordIndex0 (lifetime, elapsedTime));\n            output1 = getColor (lifetime, elapsedTime);\n            output2 = vec4 (velocity, 0.0);\n            output6 = position;\n         }\n\n         switch (geometryType)\n         {\n            case POINT:\n            case SPRITE:\n            case GEOMETRY:\n            {\n               output3 = vec4 (1.0, 0.0, 0.0, 0.0);\n               output4 = vec4 (0.0, 1.0, 0.0, 0.0);\n               output5 = vec4 (0.0, 0.0, 1.0, 0.0);\n               break;\n            }\n            case LINE:\n            {\n               mat3 r = Matrix3 (Quaternion (vec3 (0.0, 0.0, 1.0), output2 .xyz));\n               mat3 s = mat3 (1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, particleSize .y);\n               mat3 m = r * s;\n\n               output3 = vec4 (m [0], 0.0);\n               output4 = vec4 (m [1], 0.0);\n               output5 = vec4 (m [2], 0.0);\n               break;\n            }\n            default: // QUAD, TRIANGLE\n            {\n               output3 = vec4 (particleSize .x, 0.0, 0.0, 0.0);\n               output4 = vec4 (0.0, particleSize .y, 0.0, 0.0);\n               output5 = vec4 (0.0, 0.0, 1.0, 0.0);\n               break;\n            }\n         }\n      }\n      `,i=t.createShader(t.VERTEX_SHADER);t.shaderSource(i,n),t.compileShader(i);const o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,"#version 300 es\n\n      precision highp float;\n\n      void\n      main () { }\n      "),t.compileShader(o);const r=t.createProgram();t.attachShader(r,i),t.attachShader(r,o),t.transformFeedbackVaryings(r,Array.from({length:7},((e,t)=>"output"+t)),t.INTERLEAVED_ATTRIBS),t.linkProgram(r),t.getProgramParameter(r,t.LINK_STATUS)||console.error("Couldn't initialize particle shader: "+t.getProgramInfoLog(r)),r.inputs=[[0,t.getAttribLocation(r,"input0")],[2,t.getAttribLocation(r,"input2")],[6,t.getAttribLocation(r,"input6")]],r.randomSeed=t.getUniformLocation(r,"randomSeed"),r.geometryType=t.getUniformLocation(r,"geometryType"),r.createParticles=t.getUniformLocation(r,"createParticles"),r.particleLifetime=t.getUniformLocation(r,"particleLifetime"),r.lifetimeVariation=t.getUniformLocation(r,"lifetimeVariation"),r.deltaTime=t.getUniformLocation(r,"deltaTime"),r.particleSize=t.getUniformLocation(r,"particleSize"),r.numForces=t.getUniformLocation(r,"numForces"),r.forces=t.getUniformLocation(r,"forces"),r.boundedVerticesIndex=t.getUniformLocation(r,"boundedVerticesIndex"),r.boundedNormalsIndex=t.getUniformLocation(r,"boundedNormalsIndex"),r.boundedHierarchyIndex=t.getUniformLocation(r,"boundedHierarchyIndex"),r.boundedHierarchyRoot=t.getUniformLocation(r,"boundedHierarchyRoot"),r.boundedVolume=t.getUniformLocation(r,"boundedVolume"),r.numColors=t.getUniformLocation(r,"numColors"),r.colorRamp=t.getUniformLocation(r,"colorRamp"),r.texCoordCount=t.getUniformLocation(r,"texCoordCount"),r.numTexCoords=t.getUniformLocation(r,"numTexCoords"),r.texCoordRamp=t.getUniformLocation(r,"texCoordRamp");for(const e of Object.keys(this.uniforms))r[e]=t.getUniformLocation(r,e);r.NaN=t.getUniformLocation(r,"NaN"),t.useProgram(r);for(const n of this.samplers){const i=t.getUniformLocation(r,n);t.uniform1i(i,r[n+"TextureUnit"]=e.getTexture2DUnit())}return t.uniform1f(r.NaN,NaN),e.resetTextureUnits(),r},activateTextures:function(){},createTexture:function(){const e=this.getBrowser().getContext(),t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,1,1,0,e.RGBA,e.FLOAT,new Float32Array(4)),t},getTexture2DUnit:function(e,t,n){const i=t[n];return void 0===i?t[n]=e.getTexture2DUnit():i}});const E=I;m().set("x_ite/Components/ParticleSystems/X3DParticleEmitterNode",E);const S=E,A=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Numbers/Vector3");var P=e.n(A);function N(e){S.call(this,e),this.addType(_().PointEmitter),this._position.setUnit("length"),this.addUniform("position","uniform vec3 position;"),this.addUniform("direction","uniform vec3 direction;"),this.addFunction("vec3 getRandomVelocity ()\n   {\n      if (direction == vec3 (0.0))\n         return getRandomSphericalVelocity ();\n\n      else\n         return direction * getRandomSpeed ();\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      return vec4 (position, 1.0);\n   }")}N.prototype=Object.assign(Object.create(S.prototype),{constructor:N,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"position",new(o().SFVec3f)),new(s())(_().inputOutput,"direction",new(o().SFVec3f)(0,1,0)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat))]),getTypeName:function(){return"PointEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this._direction.addInterest("set_direction__",this),this.set_position__(),this.set_direction__())},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)},set_direction__:function(){const e=new(P())(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}()});const C=N;m().set("x_ite/Components/ParticleSystems/PointEmitter",C);const D=C,B=Symbol();Symbol();function O(){}O.prototype={getDefaultEmitter:function(){return this[B]=new D(this.getPrivateScene()),this[B].setPrivate(!0),this[B].setup(),this.getDefaultEmitter=function(){return this[B]},Object.defineProperty(this,"getDefaultEmitter",{enumerable:!1}),this[B]}};const V=O;m().set("x_ite/Browser/ParticleSystems/X3DParticleSystemsContext",V);const U=V;function z(e){u().call(this,e),this.addType(_().X3DParticlePhysicsModelNode)}z.prototype=Object.assign(Object.create(u().prototype),{constructor:z,addForce:function(){}});const M=z;m().set("x_ite/Components/ParticleSystems/X3DParticlePhysicsModelNode",M);const X=M,L=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Base/X3DCast");var q=e.n(L);function j(e){X.call(this,e),this.addType(_().BoundedPhysicsModel)}j.prototype=Object.assign(Object.create(X.prototype),{constructor:j,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(s())(_().inputOutput,"geometry",new(o().SFNode))]),getTypeName:function(){return"BoundedPhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},initialize:function(){X.prototype.initialize.call(this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},set_geometry__:function(){this.geometryNode&&this.geometryNode._rebuild.removeInterest("addNodeEvent",this),this.geometryNode=q()(_().X3DGeometryNode,this._geometry),this.geometryNode&&this.geometryNode._rebuild.addInterest("addNodeEvent",this)},addGeometry:function(e,t){if(this.geometryNode&&this._enabled.getValue()){const n=this.geometryNode.getNormals().getValue(),i=this.geometryNode.getVertices().getValue();for(const t of n)e.push(t);for(const e of i)t.push(e)}}});const H=j;m().set("x_ite/Components/ParticleSystems/BoundedPhysicsModel",H);const G=H;function k(e){S.call(this,e),this.addType(_().ConeEmitter),this._position.setUnit("length"),this._angle.setUnit("angle"),this.addUniform("position","uniform vec3  position;"),this.addUniform("direction","uniform vec3  direction;"),this.addUniform("angle","uniform float angle;"),this.addFunction("vec3 getRandomVelocity ()\n   {\n      if (direction == vec3 (0.0))\n      {\n         return getRandomSphericalVelocity ();\n      }\n      else\n      {\n         vec3  normal = getRandomNormalWithDirectionAndAngle (direction, angle);\n         float speed  = getRandomSpeed ();\n\n         return normal * speed;\n      }\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      return vec4 (position, 1.0);\n   }")}k.prototype=Object.assign(Object.create(S.prototype),{constructor:k,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"position",new(o().SFVec3f)),new(s())(_().inputOutput,"direction",new(o().SFVec3f)(0,1,0)),new(s())(_().inputOutput,"angle",new(o().SFFloat)(.7854)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat))]),getTypeName:function(){return"ConeEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this._direction.addInterest("set_direction__",this),this._angle.addInterest("set_angle__",this),this.set_position__(),this.set_direction__(),this.set_angle__())},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)},set_direction__:function(){const e=this._direction.getValue();this.setUniform("uniform3f","direction",e.x,e.y,e.z)},set_angle__:function(){this.setUniform("uniform1f","angle",this._angle.getValue())}});const Y=k;m().set("x_ite/Components/ParticleSystems/ConeEmitter",Y);const W=Y;function K(e){S.call(this,e),this.addType(_().ExplosionEmitter),this._position.setUnit("length"),this.addUniform("position","uniform vec3 position;"),this.addFunction("vec3 getRandomVelocity ()\n   {\n      return getRandomSphericalVelocity ();\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      return vec4 (position, 1.0);\n   }")}K.prototype=Object.assign(Object.create(S.prototype),{constructor:K,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"position",new(o().SFVec3f)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat))]),getTypeName:function(){return"ExplosionEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this),this.getBrowser().getContext().getVersion()<2||(this._position.addInterest("set_position__",this),this.set_position__())},isExplosive:function(){return!0},set_position__:function(){const e=this._position.getValue();this.setUniform("uniform3f","position",e.x,e.y,e.z)}});const Z=K;m().set("x_ite/Components/ParticleSystems/ExplosionEmitter",Z);const Q=Z;function $(e){X.call(this,e),this.addType(_().ForcePhysicsModel),this._force.setUnit("force")}$.prototype=Object.assign(Object.create(X.prototype),{constructor:$,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(s())(_().inputOutput,"force",new(o().SFVec3f)(0,-9.8,0))]),getTypeName:function(){return"ForcePhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},addForce:function(){const e=new(P())(0,0,0);return function(t,n,i,o){return!!this._enabled.getValue()&&(o.set(e.assign(this._force.getValue()).multiply(i),4*t),o[4*t+3]=0,!0)}}()});const J=$;m().set("x_ite/Components/ParticleSystems/ForcePhysicsModel",J);const ee=J,te=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Components/Shape/X3DShapeNode");var ne=e.n(te);const ie=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Browser/Rendering/GeometryContext");var oe=e.n(ie);const re=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Rendering/VertexArray");var se=e.n(re);const ae=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Rendering/TraverseType");var ce=e.n(ae);const le=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Browser/Shape/AlphaMode");var ue=e.n(le);const de=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Numbers/Matrix4");var me=e.n(de);const he=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Numbers/Matrix3");var pe=e.n(he);const fe=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Geometry/Plane3");var xe=e.n(fe);const _e=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Algorithms/QuickSort");var ge=e.n(_e);const ye=new(P())(0,0,0),ve=new(P())(0,0,0),Te=new(P())(0,0,0),we={u:0,v:0,t:0},Re=[new(P())(0,0,1),new(P())(0,0,-1),new(P())(0,1,0),new(P())(0,-1,0),new(P())(1,0,0)];function be(e,t){this.vertices=e.vertices,this.normals=e.normals,this.triangle=t,this.i4=12*t,this.i3=9*t}function Fe(e,t,n,i){this.min=new(P())(0,0,0),this.max=new(P())(0,0,0),this.planes=[],this.intersection=new(P())(0,0,0);const o=e.vertices,r=this.min,s=this.max,a=n+i;let c=12*t[n];r.set(o[c],o[c+1],o[c+2]),s.assign(r);for(let e=n;e<a;++e)c=12*t[e],ye.set(o[c],o[c+1],o[c+2]),ve.set(o[c+4],o[c+5],o[c+6]),Te.set(o[c+8],o[c+9],o[c+10]),r.min(ye,ve,Te),s.max(ye,ve,Te);for(let e=0;e<5;++e)this.planes[e]=new(xe())(e%2?r:s,Re[e]);if(i>2){e.sorter.compare.axis=this.getLongestAxis(r,s),e.sorter.sort(n,a);var l=i>>>1}else l=1;const u=i-l;this.left=l>1?new Fe(e,t,n,l):new be(e,t[n]),this.right=u>1?new Fe(e,t,n+l,u):new be(e,t[n+l])}function Ie(e,t){const n=e.length/12;switch(this.vertices=e,this.normals=t,n){case 0:this.root=null;break;case 1:this.root=new be(this,0);break;default:{const t=[];for(let e=0;e<n;++e)t.push(e);this.sorter=new(ge())(t,function(e,t){return function(n,i){return Math.min(e[n+t],e[n+4+t],e[n+8+t])<Math.min(e[i+t],e[i+4+t],e[i+8+t])}}(e,0)),this.root=new Fe(this,t,0,n);break}}}be.prototype={intersectsLine:function(e,t,n){const i=this.vertices,o=this.normals,r=this.i4,s=this.i3;if(ye.x=i[r],ye.y=i[r+1],ye.z=i[r+2],ve.x=i[r+4],ve.y=i[r+5],ve.z=i[r+6],Te.x=i[r+8],Te.y=i[r+9],Te.z=i[r+10],e.intersectsTriangle(ye,ve,Te,we)){const e=we.u,a=we.v,c=1-e-a,l=t.size++;l>=t.length&&t.push(new(P())(0,0,0)),t[l].set(c*i[r]+e*i[r+4]+a*i[r+8],c*i[r+1]+e*i[r+5]+a*i[r+9],c*i[r+2]+e*i[r+6]+a*i[r+10]),n&&(l>=n.length&&n.push(new(P())(0,0,0)),n[l].set(c*o[s]+e*o[s+3]+a*o[s+6],c*o[s+1]+e*o[s+4]+a*o[s+7],c*o[s+2]+e*o[s+5]+a*o[s+8]))}},toArray:function(e){const t=e.length/4;return e.push(1,3*this.triangle,0,0),t}},Fe.prototype={intersectsLine:function(e,t,n){this.intersectsBBox(e)&&(this.left.intersectsLine(e,t,n),this.right.intersectsLine(e,t,n))},intersectsBBox:function(e){const t=this.planes,n=this.min,i=this.max,o=n.x,r=i.x,s=n.y,a=i.y,c=n.z,l=i.z,u=this.intersection;return!!(t[0].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.y>=s&&u.y<=a)||(!!(t[1].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.y>=s&&u.y<=a)||(!!(t[2].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.z>=c&&u.z<=l)||(!!(t[3].intersectsLine(e,u)&&u.x>=o&&u.x<=r&&u.z>=c&&u.z<=l)||!!(t[4].intersectsLine(e,u)&&u.y>=s&&u.y<=a&&u.z>=c&&u.z<=l))))},getLongestAxis:function(e,t){const n=t.x-e.x,i=t.y-e.y,o=t.z-e.z;return n<i?i<o?2:1:n<o?2:0},toArray:function(e){const t=this.left.toArray(e),n=this.right.toArray(e),i=this.min,o=this.max,r=e.length/4;return e.push(0,t,n,0,i.x,i.y,i.z,0,o.x,o.y,o.z,0),r}},Ie.prototype={constructor:Ie,intersectsLine:function(e,t,n){return t.size=0,this.root?(this.root.intersectsLine(e,t,n),t.size):0},toArray:function(e){if(this.root){const t=this.root.toArray(e);e.push(t,0,0,0)}return e}};const Ee=Ie;m().set("standard/Math/Utility/BVH",Ee);const Se=Ee,Ae=new Float32Array([0,0,0,1]),Pe=new Float32Array([0,0,0,1,1,0,0,1,0,0,-.5,1,0,0,.5,1]),Ne=new Float32Array([0,0,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,-.5,-.5,0,1,.5,-.5,0,1,.5,.5,0,1,-.5,-.5,0,1,.5,.5,0,1,-.5,.5,0,1]);function Ce(e){ne().call(this,e),this.addType(_().ParticleSystem),this._particleSize.setUnit("length");const t=this.getBrowser();this.maxParticles=0,this.numParticles=0,this.forcePhysicsModelNodes=[],this.forces=new Float32Array(4),this.boundedPhysicsModelNodes=[],this.boundedNormals=[],this.boundedVertices=[],this.colorRamp=new Float32Array,this.texCoordRamp=new Float32Array,this.geometryContext=new(oe())({textureCoordinateNode:t.getDefaultTextureCoordinate()}),this.creationTime=0,this.pauseTime=0,this.deltaTime=0,this.particleStride=7*Float32Array.BYTES_PER_ELEMENT*4,this.particleOffsets=Array.from({length:7},((e,t)=>4*Float32Array.BYTES_PER_ELEMENT*t)),this.particleOffset=this.particleOffsets[0],this.colorOffset=this.particleOffsets[1],this.matrixOffset=this.particleOffsets[3],this.texCoordOffset=0}Ce.prototype=Object.assign(Object.create(ne().prototype),{constructor:Ce,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(s())(_().inputOutput,"createParticles",new(o().SFBool)(!0)),new(s())(_().initializeOnly,"geometryType",new(o().SFString)("QUAD")),new(s())(_().inputOutput,"maxParticles",new(o().SFInt32)(200)),new(s())(_().inputOutput,"particleLifetime",new(o().SFFloat)(5)),new(s())(_().inputOutput,"lifetimeVariation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"particleSize",new(o().SFVec2f)(.02,.02)),new(s())(_().initializeOnly,"emitter",new(o().SFNode)),new(s())(_().initializeOnly,"physics",new(o().MFNode)),new(s())(_().initializeOnly,"colorKey",new(o().MFFloat)),new(s())(_().initializeOnly,"colorRamp",new(o().SFNode)),new(s())(_().initializeOnly,"texCoordKey",new(o().MFFloat)),new(s())(_().initializeOnly,"texCoordRamp",new(o().SFNode)),new(s())(_().outputOnly,"isActive",new(o().SFBool)),new(s())(_().inputOutput,"visible",new(o().SFBool)(!0)),new(s())(_().inputOutput,"castShadow",new(o().SFBool)(!0)),new(s())(_().inputOutput,"bboxDisplay",new(o().SFBool)),new(s())(_().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(s())(_().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(s())(_().inputOutput,"appearance",new(o().SFNode)),new(s())(_().inputOutput,"geometry",new(o().SFNode))]),getTypeName:function(){return"ParticleSystem"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"children"},initialize:function(){ne().prototype.initialize.call(this);const e=this.getBrowser();e.getContext().getVersion()<2||(this.isLive().addInterest("set_live__",this),this._enabled.addInterest("set_enabled__",this),this._createParticles.addInterest("set_createParticles__",this),this._geometryType.addInterest("set_geometryType__",this),this._geometryType.addInterest("set_texCoord__",this),this._maxParticles.addInterest("set_enabled__",this),this._particleLifetime.addInterest("set_particleLifetime__",this),this._lifetimeVariation.addInterest("set_lifetimeVariation__",this),this._emitter.addInterest("set_emitter__",this),this._physics.addInterest("set_physics__",this),this._colorKey.addInterest("set_color__",this),this._colorRamp.addInterest("set_colorRamp__",this),this._texCoordKey.addInterest("set_texCoord__",this),this._texCoordRamp.addInterest("set_texCoordRamp__",this),this.inputParticles=this.createBuffer(),this.outputParticles=this.createBuffer(),this.inputParticles.emitterArrayObject=new(se()),this.inputParticles.vertexArrayObject=new(se()),this.inputParticles.shadowArrayObject=new(se()),this.outputParticles.emitterArrayObject=new(se()),this.outputParticles.vertexArrayObject=new(se()),this.outputParticles.shadowArrayObject=new(se()),this.forcesTexture=this.createTexture(),this.boundedTexture=this.createTexture(),this.colorRampTexture=this.createTexture(),this.texCoordRampTexture=this.createTexture(),this.geometryBuffer=this.createBuffer(),this.texCoordBuffers=new Array(e.getMaxTextures()).fill(this.geometryBuffer),this.set_emitter__(),this.set_enabled__(),this.set_geometryType__(),this.set_createParticles__(),this.set_particleLifetime__(),this.set_lifetimeVariation__(),this.set_physics__(),this.set_colorRamp__(),this.set_texCoordRamp__())},getShapeKey:function(){return this.numTexCoords?"2":"1"},set_bbox__:function(){this._bboxSize.getValue().equals(this.getDefaultBBoxSize())?this.bbox.set():this.bbox.set(this._bboxSize.getValue(),this._bboxCenter.getValue()),this.bboxSize.assign(this.bbox.size),this.bboxCenter.assign(this.bbox.center)},set_transparent__:function(){if(this.getAppearance().getAlphaMode()===ue().AUTO)if(this.geometryType===f.POINT)this.setTransparent(!0);else this.setTransparent(this.getAppearance().getTransparent()||this.colorRampNode&&this.colorRampNode.getTransparent()||this.geometryType===f.GEOMETRY&&this.geometryNode&&this.geometryNode.getTransparent());else this.setTransparent(this.getAppearance().getTransparent())},set_live__:function(){this.isLive().getValue()?this._isActive.getValue()&&this._maxParticles.getValue()&&(this.getBrowser().sensorEvents().addInterest("animateParticles",this),this.pauseTime&&(this.creationTime+=Date.now()/1e3-this.pauseTime,this.pauseTime=0)):this._isActive.getValue()&&this._maxParticles.getValue()&&(this.getBrowser().sensorEvents().removeInterest("animateParticles",this),0===this.pauseTime&&(this.pauseTime=Date.now()/1e3))},set_enabled__:function(){this._enabled.getValue()&&this._maxParticles.getValue()?this._isActive.getValue()||(this.isLive().getValue()?(this.getBrowser().sensorEvents().addInterest("animateParticles",this),this.pauseTime=0):this.pauseTime=Date.now()/1e3,this._isActive=!0,delete this.traverse):this._isActive.getValue()&&(this.isLive().getValue()&&this.getBrowser().sensorEvents().removeInterest("animateParticles",this),this._isActive=!1,this.numParticles=0,this.traverse=Function.prototype),this.set_maxParticles__()},set_createParticles__:function(){this.createParticles=this._createParticles.getValue()},set_geometryType__:function(){const e=this.getBrowser().getContext();switch(this.geometryType=this.getEnum(f,this._geometryType.getValue(),f.QUAD),this.geometryType){case f.POINT:this.geometryContext.geometryType=0,this.geometryContext.hasNormals=!1,this.texCoordCount=0,this.vertexCount=1,this.hasNormals=!1,this.verticesOffset=0,this.primitiveMode=e.POINTS,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,Ae,e.DYNAMIC_DRAW);break;case f.LINE:this.geometryContext.geometryType=1,this.geometryContext.hasNormals=!1,this.texCoordCount=2,this.vertexCount=2,this.hasNormals=!1,this.texCoordsOffset=0,this.verticesOffset=8*Float32Array.BYTES_PER_ELEMENT,this.primitiveMode=e.LINES,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,Pe,e.DYNAMIC_DRAW);break;case f.TRIANGLE:case f.QUAD:case f.SPRITE:this.geometryContext.geometryType=2,this.geometryContext.hasNormals=!0,this.texCoordCount=4,this.vertexCount=6,this.hasNormals=!0,this.texCoordsOffset=0,this.normalOffset=24*Float32Array.BYTES_PER_ELEMENT,this.verticesOffset=27*Float32Array.BYTES_PER_ELEMENT,this.primitiveMode=e.TRIANGLES,e.bindBuffer(e.ARRAY_BUFFER,this.geometryBuffer),e.bufferData(e.ARRAY_BUFFER,Ne,e.DYNAMIC_DRAW);break;case f.GEOMETRY:this.texCoordCount=0}this.geometryContext.updateGeometryKey(),this.updateVertexArrays(),this.set_transparent__()},set_maxParticles__:function(){const e=this.numParticles,t=Math.max(0,this._maxParticles.getValue());this.maxParticles=t,this.numParticles=Math.min(e,t),this.emitterNode.isExplosive()||(this.creationTime=Date.now()/1e3),this.resizeBuffers(e),this.updateVertexArrays()},set_particleLifetime__:function(){this.particleLifetime=this._particleLifetime.getValue()},set_lifetimeVariation__:function(){this.lifetimeVariation=this._lifetimeVariation.getValue()},set_emitter__:function(){this.emitterNode=q()(_().X3DParticleEmitterNode,this._emitter),this.emitterNode||(this.emitterNode=this.getBrowser().getDefaultEmitter()),this.createParticles=this._createParticles.getValue()},set_physics__:function(){const e=this._physics.getValue(),t=this.forcePhysicsModelNodes,n=this.boundedPhysicsModelNodes;for(let e=0,t=n.length;e<t;++e)n[e].removeInterest("set_boundedPhysics__",this);t.length=0,n.length=0;for(let i=0,o=e.length;i<o;++i)try{const o=e[i].getValue().getInnerNode(),r=o.getType();for(let e=r.length-1;e>=0;--e){switch(r[e]){case _().ForcePhysicsModel:case _().WindPhysicsModel:t.push(o);break;case _().BoundedPhysicsModel:o.addInterest("set_boundedPhysics__",this),n.push(o);break;default:continue}break}}catch(e){}this.set_boundedPhysics__()},set_boundedPhysics__:function(){const e=this.getBrowser().getContext(),t=this.boundedPhysicsModelNodes,n=this.boundedNormals,i=this.boundedVertices;n.length=0,i.length=0;for(let e=0,o=t.length;e<o;++e)t[e].addGeometry(n,i);const o=new Se(i,n).toArray([]),r=i.length/4,s=n.length/3,a=o.length/4,c=Math.ceil(Math.sqrt(r+s+a)),l=new Float32Array(c*c*4);this.boundedVerticesIndex=0,this.boundedNormalsIndex=r,this.boundedHierarchyIndex=this.boundedNormalsIndex+s,this.boundedHierarchyRoot=this.boundedHierarchyIndex+a-1,l.set(i);for(let e=4*this.boundedNormalsIndex,t=0,i=n.length;t<i;e+=4,t+=3)l[e+0]=n[t+0],l[e+1]=n[t+1],l[e+2]=n[t+2];l.set(o,4*this.boundedHierarchyIndex),c&&(e.bindTexture(e.TEXTURE_2D,this.boundedTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,c,c,0,e.RGBA,e.FLOAT,l))},set_colorRamp__:function(){this.colorRampNode&&this.colorRampNode.removeInterest("set_color__",this),this.colorRampNode=q()(_().X3DColorNode,this._colorRamp),this.colorRampNode&&this.colorRampNode.addInterest("set_color__",this),this.set_color__(),this.set_transparent__()},set_color__:function(){const e=this.getBrowser().getContext(),t=this._colorKey,n=t.length,i=Math.ceil(Math.sqrt(2*n));let o=this.colorRamp;i*i*4>o.length&&(o=this.colorRamp=new Float32Array(i*i*4));for(let e=0;e<n;++e)o[4*e]=t[e];this.colorRampNode?o.set(this.colorRampNode.addColors([],n).slice(0,4*n),4*n):o.fill(1,4*n),i&&(e.bindTexture(e.TEXTURE_2D,this.colorRampTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,i,i,0,e.RGBA,e.FLOAT,o)),this.numColors=n,this.geometryContext.colorMaterial=!(!n||!this.colorRampNode),this.geometryContext.updateGeometryKey(),this.updateVertexArrays()},set_texCoordRamp__:function(){this.texCoordRampNode&&this.texCoordRampNode.removeInterest("set_texCoord__",this),this.texCoordRampNode=q()(_().X3DTextureCoordinateNode,this._texCoordRamp),this.texCoordRampNode&&this.texCoordRampNode.addInterest("set_texCoord__",this),this.set_texCoord__()},set_texCoord__:function(){const e=this.getBrowser().getContext(),t=this._texCoordKey,n=t.length,i=Math.ceil(Math.sqrt(n+n*this.texCoordCount));let o=this.texCoordRamp;i*i*4>o.length?o=this.texCoordRamp=new Float32Array(i*i*4):o.fill(0);for(let e=0;e<n;++e)o[4*e]=t[e];this.texCoordRampNode&&o.set(this.texCoordRampNode.getTexCoord([]).slice(0,n*this.texCoordCount*4),4*n),i&&(e.bindTexture(e.TEXTURE_2D,this.texCoordRampTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,i,i,0,e.RGBA,e.FLOAT,o)),this.numTexCoords=this.texCoordRampNode?n:0,this.updateVertexArrays()},updateVertexArrays:function(){this.inputParticles.vertexArrayObject.update(),this.inputParticles.shadowArrayObject.update(),this.inputParticles.emitterArrayObject.update(),this.outputParticles.vertexArrayObject.update(),this.outputParticles.shadowArrayObject.update(),this.outputParticles.emitterArrayObject.update()},createTexture:function(){const e=this.getBrowser().getContext(),t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.RGBA32F,1,1,0,e.RGBA,e.FLOAT,new Float32Array(4)),t},createBuffer:function(){const e=this.getBrowser().getContext(),t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Uint32Array,e.DYNAMIC_DRAW),t},resizeBuffers:function(e){const t=this.getBrowser().getContext(),n=this.maxParticles,i=this.particleStride,o=Object.assign(t.createBuffer(),this.outputParticles),r=new Uint8Array(n*i);t.bindBuffer(t.ARRAY_BUFFER,this.inputParticles),t.bufferData(t.ARRAY_BUFFER,r,t.DYNAMIC_DRAW),t.bindBuffer(t.COPY_READ_BUFFER,this.outputParticles),t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,r,t.DYNAMIC_DRAW),t.copyBufferSubData(t.COPY_READ_BUFFER,t.ARRAY_BUFFER,0,0,Math.min(n*i,e*i)),t.deleteBuffer(this.outputParticles),this.outputParticles=o},animateParticles:function(){const e=this.getBrowser(),t=e.getContext(),n=this.emitterNode,i=1/Math.max(10,this.getBrowser().getCurrentFrameRate());let o=this.deltaTime=(14*this.deltaTime+i)/15;if(n.isExplosive()){const e=Date.now()/1e3,t=this.particleLifetime+this.particleLifetime*this.lifetimeVariation;e-this.creationTime>t?(this.creationTime=e,this.numParticles=this.maxParticles,this.createParticles=this._createParticles.getValue(),o=Number.POSITIVE_INFINITY):this.createParticles=!1}else if(this.numParticles<this.maxParticles){const e=Date.now()/1e3,t=Math.max(0,Math.floor((e-this.creationTime)*this.maxParticles/this.particleLifetime));t&&(this.creationTime=e),this.numParticles=Math.min(this.maxParticles,this.numParticles+t)}if(n.getMass()){const e=this.forcePhysicsModelNodes;let i=e.length,r=this.forces,s=o/n.getMass();4*i>r.length&&(r=this.forces=new Float32Array(4*i));let a=0;for(let t=0;t<i;++t)a+=!e[t].addForce(t-a,n,s,r);this.numForces=i-=a,i&&(t.bindTexture(t.TEXTURE_2D,this.forcesTexture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA32F,i,1,0,t.RGBA,t.FLOAT,r))}else this.numForces=0;const r=this.outputParticles;this.outputParticles=this.inputParticles,this.inputParticles=r,n.animate(this,o),e.addBrowserEvent()},updateSprite:function(){const e=new Float32Array(Ne),t=[new(P())(-.5,-.5,0),new(P())(.5,-.5,0),new(P())(.5,.5,0),new(P())(-.5,-.5,0),new(P())(.5,.5,0),new(P())(-.5,.5,0)],n=new(P())(0,0,0),i=new(P())(0,0,0);return function(o,r){for(let t=0;t<3;++t)e[24+t]=r[6+t];i.set(this._particleSize.x,this._particleSize.y,1);for(let o=0;o<6;++o){const s=27+4*o;r.multVecMatrix(n.assign(t[o]).multVec(i)),e[s+0]=n.x,e[s+1]=n.y,e[s+2]=n.z}o.bindBuffer(o.ARRAY_BUFFER,this.geometryBuffer),o.bufferData(o.ARRAY_BUFFER,e,o.DYNAMIC_DRAW)}}(),intersectsBox:function(e,t){},traverse:function(e,t){switch(e){case ce().POINTER:case ce().PICKING:case ce().COLLISION:break;case ce().SHADOW:this._castShadow.getValue()&&t.addShadowShape(this);break;case ce().DISPLAY:t.addDisplayShape(this)&&this.getAppearance().traverse(e,t)}this.geometryType===f.GEOMETRY&&this.getGeometry()&&this.getGeometry().traverse(e,t)},depth:function(e,t,n){if(this.numParticles){const i=t.clipPlanes,o=this.getBrowser().getDepthShader(i.length,!0);switch(o.enable(e),o.setClipPlanes(e,i),e.uniformMatrix4fv(o.x3d_ProjectionMatrix,!1,n),e.uniformMatrix4fv(o.x3d_ModelViewMatrix,!1,t.modelViewMatrix),this.geometryType){case f.GEOMETRY:{const n=this.getGeometry();n&&n.displayParticlesDepth(e,t,o,this);break}case f.SPRITE:this.updateSprite(e,this.getScreenAlignedRotation(t.modelViewMatrix));default:{const t=this.outputParticles;if(t.shadowArrayObject.enable(e,o)){const n=this.particleStride;o.enableParticleAttribute(e,t,n,this.particleOffset,1),o.enableParticleMatrixAttribute(e,t,n,this.matrixOffset,1),o.enableVertexAttribute(e,this.geometryBuffer,0,this.verticesOffset)}e.drawArraysInstanced(this.primitiveMode,0,this.vertexCount,this.numParticles);break}}}},display:function(e,t){switch(this.geometryType){case f.GEOMETRY:if(this.numParticles){const n=this.getGeometry();n&&n.displayParticles(e,t,this)}break;case f.SPRITE:this.updateSprite(e,this.getScreenAlignedRotation(t.modelViewMatrix));case f.QUAD:case f.TRIANGLE:{const n=me().prototype.determinant3.call(t.modelViewMatrix)>0;e.frontFace(n?e.CCW:e.CW),e.enable(e.CULL_FACE),e.cullFace(e.BACK)}default:{const n=this.getBrowser(),i=this.getAppearance(),o=i.getShader(this.geometryContext,t),r=n.getPrimitiveMode(this.primitiveMode);if(this.numParticles){const s=i.getBlendMode();if(s&&s.enable(e),o.enable(e),o.setUniforms(e,this.geometryContext,t),this.numTexCoords){const t=n.getTexture2DUnit();e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,this.texCoordRampTexture),e.uniform1i(o.x3d_TexCoordRamp,t)}const a=this.outputParticles;if(a.vertexArrayObject.enable(e,o)){const t=this.particleStride;o.enableParticleAttribute(e,a,t,this.particleOffset,1),o.enableParticleMatrixAttribute(e,a,t,this.matrixOffset,1),this.geometryContext.colorMaterial&&(o.enableColorAttribute(e,a,t,this.colorOffset),o.colorAttributeDivisor(e,1)),this.texCoordCount&&o.enableTexCoordAttribute(e,this.texCoordBuffers,0,this.texCoordOffset),this.hasNormals&&(o.enableNormalAttribute(e,this.geometryBuffer,0,this.normalOffset),o.normalAttributeDivisor(e,this.maxParticles)),o.enableVertexAttribute(e,this.geometryBuffer,0,this.verticesOffset)}e.drawArraysInstanced(r,0,this.vertexCount,this.numParticles),s&&s.disable(e)}break}}},getScreenAlignedRotation:function(){const e=new(me()),t=new(P())(0,0,0),n=new(P())(0,0,0),i=new(P())(0,0,0),o=new(pe())(9);return function(r){e.assign(r).inverse(),e.multDirMatrix(t.assign(P().zAxis)),e.multDirMatrix(n.assign(P().yAxis));const s=n.cross(t);i.assign(t).cross(s);const a=t;return s.normalize(),i.normalize(),a.normalize(),o.set(s.x,s.y,s.z,i.x,i.y,i.z,a.x,a.y,a.z),o}}()});const De=Ce;m().set("x_ite/Components/ParticleSystems/ParticleSystem",De);const Be=De,Oe=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Components/Rendering/IndexedLineSet");var Ve=e.n(Oe);function Ue(e){S.call(this,e),this.addType(_().PolylineEmitter),this.polylinesNode=new(Ve())(e),this.polylinesArray=new Float32Array,this.addSampler("polylines"),this.addUniform("direction","uniform vec3 direction;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("polylines","uniform sampler2D polylines;"),this.addFunction("vec3 getRandomVelocity ()\n   {\n      if (direction == vec3 (0.0))\n         return getRandomSphericalVelocity ();\n\n      else\n         return direction * getRandomSpeed ();\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      if (verticesIndex < 0)\n      {\n         return vec4 (NaN);\n      }\n      else\n      {\n         // Determine index0, index1 and weight.\n\n         float lastLengthSoFar = texelFetch (polylines, verticesIndex - 1, 0) .x;\n         float fraction        = random () * lastLengthSoFar;\n\n         int   index0 = 0;\n         int   index1 = 0;\n         float weight = 0.0;\n\n         interpolate (polylines, verticesIndex, fraction, index0, index1, weight);\n\n         // Interpolate and return position.\n\n         index0 *= 2;\n         index1  = index0 + 1;\n\n         vec4 vertex0 = texelFetch (polylines, verticesIndex + index0, 0);\n         vec4 vertex1 = texelFetch (polylines, verticesIndex + index1, 0);\n\n         return mix (vertex0, vertex1, weight);\n      }\n   }")}Ue.prototype=Object.assign(Object.create(S.prototype),{constructor:Ue,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"direction",new(o().SFVec3f)(0,1,0)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat)),new(s())(_().inputOutput,"coordIndex",new(o().MFInt32)(-1)),new(s())(_().inputOutput,"coord",new(o().SFNode))]),getTypeName:function(){return"PolylineEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.polylinesTexture=this.createTexture(),this._direction.addInterest("set_direction__",this),this._coordIndex.addFieldInterest(this.polylinesNode._coordIndex),this._coord.addFieldInterest(this.polylinesNode._coord),this.polylinesNode._coordIndex=this._coordIndex,this.polylinesNode._coord=this._coord,this.polylinesNode._rebuild.addInterest("set_polyline",this),this.polylinesNode.setPrivate(!0),this.polylinesNode.setup(),this.set_direction__(),this.set_polyline())},set_direction__:function(){const e=new(P())(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}(),set_polyline:function(){const e=new(P())(0,0,0),t=new(P())(0,0,0);return function(){const n=this.getBrowser().getContext(),i=this.polylinesNode.getVertices().getValue(),o=i.length/4,r=o/2+1,s=Math.ceil(Math.sqrt(r+o)),a=r;let c=this.polylinesArray;c.length<s*s*4&&(c=this.polylinesArray=new Float32Array(s*s*4));let l=0;for(let n=0,o=i.length;n<o;n+=8)e.set(i[n],i[n+1],i[n+2]),t.set(i[n+4],i[n+5],i[n+6]),c[n/2+4]=l+=t.subtract(e).magnitude();c.set(i,4*a),this.setUniform("uniform1i","verticesIndex",o?a:-1),s&&(n.bindTexture(n.TEXTURE_2D,this.polylinesTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,s,s,0,n.RGBA,n.FLOAT,c))}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.polylinesTextureUnit),e.bindTexture(e.TEXTURE_2D,this.polylinesTexture)}});const ze=Ue;m().set("x_ite/Components/ParticleSystems/PolylineEmitter",ze);const Me=ze,Xe=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Geometry/Triangle3");var Le=e.n(Xe);function qe(e){S.call(this,e),this.addType(_().SurfaceEmitter),this.surfaceNode=null,this.surfaceArray=new Float32Array,this.addSampler("surface"),this.addUniform("solid","uniform bool solid;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("normalsIndex","uniform int normalsIndex;"),this.addUniform("surface","uniform sampler2D surface;"),this.addFunction("vec4 position; vec3 getRandomVelocity ()\n   {\n      if (verticesIndex < 0)\n      {\n         return vec3 (0.0);\n      }\n      else\n      {\n         vec3 normal;\n\n         getRandomPointOnSurface (surface, verticesIndex, normalsIndex, position, normal);\n\n         if (solid == false && random () > 0.5)\n            normal = -normal;\n\n         return normal * getRandomSpeed ();\n      }\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      return verticesIndex < 0 ? vec4 (NaN) : position;\n   }")}qe.prototype=Object.assign(Object.create(S.prototype),{constructor:qe,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat)),new(s())(_().inputOutput,"surface",new(o().SFNode))]),getTypeName:function(){return"SurfaceEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.surfaceTexture=this.createTexture(),this._surface.addInterest("set_surface__",this),this.set_surface__())},set_surface__:function(){this.surfaceNode&&(this.surfaceNode._solid.removeInterest("set_solid__",this),this.surfaceNode._rebuild.removeInterest("set_geometry__",this)),this.surfaceNode=q()(_().X3DGeometryNode,this._surface),this.surfaceNode&&(this.surfaceNode._solid.addInterest("set_solid__",this),this.surfaceNode._rebuild.addInterest("set_geometry__",this)),this.set_solid__(),this.set_geometry__()},set_solid__:function(){this.surfaceNode&&this.setUniform("uniform1i","solid",this.surfaceNode._solid.getValue())},set_geometry__:function(){const e=new(P())(0,0,0),t=new(P())(0,0,0),n=new(P())(0,0,0);return function(){const i=this.getBrowser().getContext();if(this.surfaceNode){const o=this.surfaceNode.getVertices().getValue(),r=this.surfaceNode.getNormals().getValue(),s=o.length/4,a=s/3+1,c=Math.ceil(Math.sqrt(a+s+s)),l=a,u=l+s;let d=this.surfaceArray;d.length<c*c*4&&(d=this.surfaceArray=new Float32Array(c*c*4));let m=0;for(let i=0,r=o.length;i<r;i+=12)e.set(o[i],o[i+1],o[i+2]),t.set(o[i+4],o[i+5],o[i+6]),n.set(o[i+8],o[i+9],o[i+10]),d[i/3+4]=m+=Le().area(e,t,n);d.set(o,4*l);for(let e=4*u,t=0,n=r.length;t<n;e+=4,t+=3)d[e+0]=r[t+0],d[e+1]=r[t+1],d[e+2]=r[t+2];this.setUniform("uniform1i","verticesIndex",s?l:-1),this.setUniform("uniform1i","normalsIndex",s?u:-1),c&&(i.bindTexture(i.TEXTURE_2D,this.surfaceTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA32F,c,c,0,i.RGBA,i.FLOAT,d))}else this.setUniform("uniform1i","verticesIndex",-1),this.setUniform("uniform1i","normalsIndex",-1)}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.surfaceTextureUnit),e.bindTexture(e.TEXTURE_2D,this.surfaceTexture)}});const je=qe;m().set("x_ite/Components/ParticleSystems/SurfaceEmitter",je);const He=je,Ge=window[Symbol.for("X_ITE.X3D-8.4.3")].require("x_ite/Components/Geometry3D/IndexedFaceSet");var ke=e.n(Ge);function Ye(e){S.call(this,e),this.addType(_().VolumeEmitter),this.volumeNode=new(ke())(e),this.volumeArray=new Float32Array,this.addSampler("volume"),this.addUniform("direction","uniform vec3 direction;"),this.addUniform("verticesIndex","uniform int verticesIndex;"),this.addUniform("normalsIndex","uniform int normalsIndex;"),this.addUniform("hierarchyIndex","uniform int hierarchyIndex;"),this.addUniform("hierarchyRoot","uniform int hierarchyRoot;"),this.addUniform("volume","uniform sampler2D volume;"),this.addFunction("vec3 getRandomVelocity ()\n   {\n      if (hierarchyRoot < 0)\n      {\n         return vec3 (0.0);\n      }\n      else\n      {\n         if (direction == vec3 (0.0))\n            return getRandomSphericalVelocity ();\n\n         else\n            return direction * getRandomSpeed ();\n      }\n   }"),this.addFunction("vec4 getRandomPosition ()\n   {\n      if (hierarchyRoot < 0)\n      {\n         return vec4 (NaN);\n      }\n      else\n      {\n         vec4 point;\n         vec3 normal;\n\n         getRandomPointOnSurface (volume, verticesIndex, normalsIndex, point, normal);\n\n         Line3 line = Line3 (point .xyz, getRandomSurfaceNormal (normal));\n\n         vec4 points [ARRAY_SIZE];\n\n         int numIntersections = getIntersections (volume, verticesIndex, hierarchyIndex, hierarchyRoot, line, points);\n\n         numIntersections -= numIntersections % 2; // We need an even count of intersections.\n\n         switch (numIntersections)\n         {\n            case 0:\n               return vec4 (0.0);\n            case 2:\n               break;\n            default:\n               sort (points, numIntersections, plane3 (line .point, line .direction));\n               break;\n         }\n\n         int index = int (fract (random ()) * float (numIntersections / 2)) * 2; // Select random intersection.\n\n         return mix (points [index], points [index + 1], random ());\n      }\n   }")}Ye.prototype=Object.assign(Object.create(S.prototype),{constructor:Ye,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"on",new(o().SFBool)(!0)),new(s())(_().inputOutput,"internal",new(o().SFBool)(!0)),new(s())(_().inputOutput,"direction",new(o().SFVec3f)(0,1,0)),new(s())(_().inputOutput,"speed",new(o().SFFloat)),new(s())(_().inputOutput,"variation",new(o().SFFloat)(.25)),new(s())(_().inputOutput,"mass",new(o().SFFloat)),new(s())(_().inputOutput,"surfaceArea",new(o().SFFloat)),new(s())(_().inputOutput,"coordIndex",new(o().MFInt32)(-1)),new(s())(_().inputOutput,"coord",new(o().SFNode))]),getTypeName:function(){return"VolumeEmitter"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"emitter"},initialize:function(){S.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this.volumeTexture=this.createTexture(),this._direction.addInterest("set_direction__",this),this._coordIndex.addFieldInterest(this.volumeNode._coordIndex),this._coord.addFieldInterest(this.volumeNode._coord),this.volumeNode._creaseAngle=Math.PI,this.volumeNode._convex=!1,this.volumeNode._coordIndex=this._coordIndex,this.volumeNode._coord=this._coord,this.volumeNode._rebuild.addInterest("set_geometry__",this),this.volumeNode.setPrivate(!0),this.volumeNode.setup(),this.set_direction__(),this.set_geometry__())},set_direction__:function(){const e=new(P())(0,0,0);return function(){e.assign(this._direction.getValue()).normalize(),this.setUniform("uniform3f","direction",e.x,e.y,e.z)}}(),set_geometry__:function(){const e=new(P())(0,0,0),t=new(P())(0,0,0),n=new(P())(0,0,0);return function(){const i=this.getBrowser().getContext(),o=this.volumeNode.getVertices().getValue(),r=this.volumeNode.getNormals().getValue(),s=new Se(o,r).toArray([]),a=o.length/4,c=r.length/3,l=a/3+1,u=s.length/4,d=Math.ceil(Math.sqrt(l+a+a+u)),m=l,h=m+a,p=h+c;let f=this.volumeArray;f.length<d*d*4&&(f=this.volumeArray=new Float32Array(d*d*4));let x=0;for(let i=0,r=o.length;i<r;i+=12)e.set(o[i],o[i+1],o[i+2]),t.set(o[i+4],o[i+5],o[i+6]),n.set(o[i+8],o[i+9],o[i+10]),f[i/3+4]=x+=Le().area(e,t,n);f.set(o,4*m);for(let e=4*h,t=0,n=r.length;t<n;e+=4,t+=3)f[e+0]=r[t+0],f[e+1]=r[t+1],f[e+2]=r[t+2];f.set(s,4*p),this.setUniform("uniform1i","verticesIndex",m),this.setUniform("uniform1i","normalsIndex",h),this.setUniform("uniform1i","hierarchyIndex",p),this.setUniform("uniform1i","hierarchyRoot",p+u-1),d&&(i.bindTexture(i.TEXTURE_2D,this.volumeTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA32F,d,d,0,i.RGBA,i.FLOAT,f))}}(),activateTextures:function(e,t){e.activeTexture(e.TEXTURE0+t.volumeTextureUnit),e.bindTexture(e.TEXTURE_2D,this.volumeTexture)}});const We=Ye;m().set("x_ite/Components/ParticleSystems/VolumeEmitter",We);const Ke=We,Ze=window[Symbol.for("X_ITE.X3D-8.4.3")].require("standard/Math/Algorithm");var Qe=e.n(Ze);function $e(e){X.call(this,e),this.addType(_().WindPhysicsModel),this._speed.setUnit("speed")}$e.prototype=Object.assign(Object.create(X.prototype),{constructor:$e,[Symbol.for("X_ITE.X3DBaseNode.fieldDefinitions")]:new(c())([new(s())(_().inputOutput,"metadata",new(o().SFNode)),new(s())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(s())(_().inputOutput,"direction",new(o().SFVec3f)),new(s())(_().inputOutput,"speed",new(o().SFFloat)(.1)),new(s())(_().inputOutput,"gustiness",new(o().SFFloat)(.1)),new(s())(_().inputOutput,"turbulence",new(o().SFFloat))]),getTypeName:function(){return"WindPhysicsModel"},getComponentName:function(){return"ParticleSystems"},getContainerField:function(){return"physics"},getRandomSpeed:function(e){const t=Math.max(0,this._speed.getValue()),n=t*Math.max(0,this._gustiness.getValue());return e.getRandomValue(Math.max(0,t-n),t+n)},addForce:function(){const e=new(P())(0,0,0);return function(t,n,i,o){if(this._enabled.getValue()){const r=n._surfaceArea.getValue(),s=this.getRandomSpeed(n),a=.64615*Math.pow(10,2*Math.log(s));return this._direction.getValue().equals(P().Zero)?n.getRandomNormal(e):e.assign(this._direction.getValue()).normalize(),o.set(e.multiply(r*a*i),4*t),o[4*t+3]=Math.PI*Qe().clamp(this._turbulence.getValue(),0,1),!0}return!1}}()});const Je=$e;m().set("x_ite/Components/ParticleSystems/WindPhysicsModel",Je);const et=Je;n().addComponent({name:"ParticleSystems",types:{BoundedPhysicsModel:G,ConeEmitter:W,ExplosionEmitter:Q,ForcePhysicsModel:ee,ParticleSystem:Be,PointEmitter:D,PolylineEmitter:Me,SurfaceEmitter:He,VolumeEmitter:Ke,WindPhysicsModel:et},abstractTypes:{X3DParticleEmitterNode:S,X3DParticlePhysicsModelNode:X},browserContext:U});const tt=void 0;m().set("assets/components/ParticleSystems",tt)})();